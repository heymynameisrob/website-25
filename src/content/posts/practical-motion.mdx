---
title: Practical Motion
description: Using motion in web interfaces
image: /src/assets/bacon-motion.jpg
imageDark: /src/assets/bacon-motion.jpg
date: 2025-11-20
type: "post"
colorScheme: "theme-blue"
---

import { UIExample } from "@/components/demos/UIExample";

Animation can bring joy to an interface.

Whether they are animations via interactions (e.g. clicking on a button) or orchestrated (e.g. animating a moving carousel), motion can give the product a way to express itself. Just like the visual style or language it uses, motion can have a certain tone or message it's trying to convey.

<UIExample component="gallery" client:load>
  Tip: You can navigate between images with arrow keys
</UIExample>

The web is traditionally a static, document-based medium. The introduction of the iPhone meant opening up a whole new world of sophisticated animations users are now accustomed to seeing. Even with new APIs and browser capability, this poses challenges on the web.

Below are lessons from adding motion to user interfaces on the web. I've learnt a lot of these over the years, particularly when working with React.

---

## Easings & Duration

Easing and duration determine how an animation _feels_.

This plays an important role in what the animation communicates.
Easing and duration can also influence the perception of speed. The popover on the left below uses `ease-in` with a slower duration so you can spot the difference. It doesn't _feel_ right because it starts slow and speeds up.

The one on the right uses `ease-out`, which has velocity from the start and comes to a gentle stop. This feels correct and the animation feels faster.

<UIExample component="motion-easing" client:load />

To know what easing & duration to choose, it comes down to experimentation. However I've found I usually stick to `150ms - 300ms` and these easings:

```css
:root {
  /* Elements enter/leave the viewport */
  --ease-out: cubic-bezier(0.215, 0.61, 0.355, 1);

  /* Elements change position on the viewport */
  --ease-in-out: cubic-bezier(0.645, 0.045, 0.355, 1);

  /* Use linear for constant, keyframe animations */
}
```

---

## Gestures

Gestures are parts of user interfaces. We use them constantly to trigger events (e.g. clicking a button, hovering over a link). Adding subtle animation can help make these moments feel alive.

<UIExample component="motion-gestures" client:load />

Adding `active:scale-[0.96]` to the button is a low-effort way to make the click feel much more tactile.

---

## Using clip-path animations

`clip-path` is an often overlooked CSS function, typically used for drawing shapes around nodes. But it works great for creating interesting animations and interactions. You can stack elements, hiding and revealing them by just changing a value.

<UIExample component="motion-clip" client:load />

Stacking these images and adding `clip-path: (0 0 var(--pos) 0)` whilst animating the value (e.g. 50%) creates this before/after slider.

---

## Between states

Animating transitions between states, such as changing the month on a calendar, can bring the interface to life. When orchestrating motion like this, I use React Motion as working with pure CSS can be fiddly.

<UIExample component="motion-calendar" client:load />

Motion is determined by the state of `key` on the motion component. The container determines the start, middle, and end state of the animation - triggered when `month` changes.

```tsx
<AnimatePresence initial={false}>
  <motion.div
    key={month}
    initial={{ x: 40, opacity: 0, filter: "blur(2px)" }}
    animate={{ x: 0, opacity: 1, filter: "blur(0px)" }}
    exit={{ x: -40, opacity: 0, filter: "blur(2px)" }}
    transition={{ type: "spring", bounce: 0, duration: 0.4 }} // Consider using ease-out
  >
    {month}
  </motion.div>
</AnimatePresence>
```

---

## Feedback and status

Animations provide feedback during pending states, transforming empty waiting time into perceived progress. It's common to see a loading spinner, but you can do so much more with it.

<UIExample component="motion-thinking" client:load />

Here we see different tool calls from an LLM. Beyond the `pending` and `resolved` state, there are sub-states for each tool call. With some React Motion, we can animate both.

```tsx
<div className="relative h-5 w-56 overflow-hidden">
  <AnimatePresence initial={false}>
    <motion.span
      key={index}
      className={cn(
        "absolute inset-0 text-sm font-medium text-gray-12 select-none",
      )}
      initial={{ y: 8, opacity: 0, filter: "blur(1px)" }}
      animate={{ y: 0, opacity: 1, filter: "blur(0px)" }}
      exit={{ y: -8, opacity: 0, filter: "blur(1px)" }}
      transition={{ duration: 0.3, ease: "easeOut" }}
    >
      {STATUSES[index]}...
    </motion.span>
  </AnimatePresence>
</div>
```

---

## Responsive size

Animating layout can cause layout shifts and expensive repainting if you're not careful. But changing the dimensions of a container helps reduce wasted space and focuses the attention.

<UIExample component="motion-responsive" client:load />

Measuring the inner content and animating the `height` value can adapt the container nicely to the content whenever it changes.

```tsx
const [ref, bounds] = useMeasure();

<motion.div
  animate={{ height: bounds.height }}
  transition={{ type: "spring", bounce: 0, duration: 0.4 }}
>
  <div ref={ref} className="inner-content">
    ...
  </div>
</motion.div>;
```

---

## Magic Text

Carefully using orchestration allows you to create more interesting animations. One of the best and simplest techniques for orchestration is **staggering**. By staggering each character, we can animate the text in like magic!

<UIExample component="motion-magic-text" client:load>
  Using a slight blur and spring animation brings this to life
</UIExample>

Separating each word allows us more control. Always remember to add the full text for screen readers so they don't announce each word separately.

```tsx
<div>
  <span className="sr-only">{word}</span>
  {words.map((w, i) => (
    <motion.span
      key={i}
      initial={{ y: 16, originY: 0.2, filter: "blur(4px)", opacity: 0 }}
      animate={{ y: 0, originY: 0.2, filter: "blur(0px)", opacity: 1 }}
      transition={{
        type: "spring",
        stiffness: 250,
        damping: 30,
        delay: i * 0.05,
      }}
    >
      {w}
    </motion.span>
  ))}
</div>
```
